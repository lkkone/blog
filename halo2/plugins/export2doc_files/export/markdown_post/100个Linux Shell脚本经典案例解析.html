<p style="">#### 1）编写hello world脚本</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写hello world脚本</p><p style="">echo "Hello World!"</p><p style="">```</p><p style="">#### 2）通过位置变量创建 Linux 系统账户及密码</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 通过位置变量创建 Linux 系统账户及密码</p><p style="">#$1 是执行脚本的第一个参数,$2 是执行脚本的第二个参数</p><p style="">useradd    "$1" </p><p style="">echo "$2"  |  passwd  ‐‐stdin  "$1"</p><p style="">```</p><p style="">#### 3）备份日志</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 每周 5 使用 tar 命令备份/var/log 下的所有日志文件</p><p style=""># vim  /root/logbak.sh</p><p style=""># 编写备份脚本,备份后的文件名包含日期标签,防止后面的备份将前面的备份数据覆盖</p><p style=""># 注意 date 命令需要使用反引号括起来,反引号在键盘&lt;tab&gt;键上面</p><p style="">tar  -czf  log<code>date +%Y%m%d</code>.tar.gz  /var/log </p><p style=""># crontab ‐e  [[编写计划任务]],执行备份脚本</p><p style="">00  03  *  *  5  /root/logbak.sh</p><p style="">```</p><p style="">#### 4）一键部署 LNMP(RPM 包版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 一键部署 LNMP(RPM 包版本)</p><p style=""># 使用 yum 安装部署 LNMP,需要提前配置好 yum 源,否则该脚本会失败</p><p style=""># 本脚本使用于 centos7.2 或 RHEL7.2</p><p style="">yum ‐y install httpd</p><p style="">yum ‐y install mariadb mariadb‐devel mariadb‐server</p><p style="">yum ‐y install php  php‐mysql</p><p style="">systemctl start httpd mariadb</p><p style="">systemctl enable httpd mariadb</p><p style="">```</p><p style="">#### 5）监控内存和磁盘容量，小于给定值时报警</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 实时监控本机内存和硬盘剩余空间,剩余内存小于500M、根分区剩余空间小于1000M时,发送报警邮件给root管理员</p><p style=""># 提取根分区剩余空间</p><p style="">disk_size=$(df / | awk '/\//{print $4}')</p><p style=""># 提取内存剩余空间</p><p style="">mem_size=$(free | awk '/Mem/{print $4}')</p><p style="">while :</p><p style="">do</p><p style=""># 注意内存和磁盘提取的空间大小都是以 Kb 为单位</p><p style="">if  [  $disk_size -le 512000 -a $mem_size -le 1024000  ]</p><p style="">then</p><p style="">    mail  ‐s  "Warning"  root  &lt;&lt;EOF</p><p style="">  Insufficient resources,资源不足</p><p style="">EOF</p><p style="">fi</p><p style="">done</p><p style="">```</p><p style="">#### 6）猜数字游戏</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 脚本生成一个 100 以内的随机数,提示用户猜数字,根据用户的输入,提示用户猜对了,</p><p style=""># 猜小了或猜大了,直至用户猜对脚本结束。</p><p style=""># RANDOM 为系统自带的系统变量,值为 0‐32767的随机数</p><p style=""># 使用取余算法将随机数变为 1‐100 的随机数</p><p style="">num=$[RANDOM%100+1]</p><p style="">echo "$num"</p><p style=""># 使用 read 提示用户猜数字</p><p style=""># 使用 if 判断用户猜数字的大小关系:‐eq(等于),‐ne(不等于),‐gt(大于),‐ge(大于等于),</p><p style=""># ‐lt(小于),‐le(小于等于)</p><p style="">while  :</p><p style="">do</p><p style="">  read -p "计算机生成了一个 1‐100 的随机数,你猜: " cai</p><p style="">    if [ $cai -eq $num ]</p><p style="">    then</p><p style="">         echo "恭喜,猜对了"</p><p style="">         exit</p><p style="">      elif [ $cai -gt $num ]</p><p style="">      then</p><p style="">             echo "Oops,猜大了"</p><p style="">        else</p><p style="">             echo "Oops,猜小了"</p><p style="">   fi</p><p style="">done</p><p style="">```</p><p style="">#### 7）检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用字串对比版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不</p><p style=""># 是,则提示您非管理员(使用字串对比版本) </p><p style="">if [ $USER == "root" ]</p><p style="">then</p><p style="">  yum ‐y install vsftpd</p><p style="">else</p><p style="">    echo "您不是管理员,没有权限安装软件"</p><p style="">fi</p><p style="">```</p><p style="">#### 8）检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用 UID 数字对比版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不</p><p style=""># 是,则提示您非管理员(使用 UID 数字对比版本)</p><p style="">if [ $UID -eq 0 ];then</p><p style="">    yum ‐y install vsftpd</p><p style="">else</p><p style="">    echo "您不是管理员,没有权限安装软件"</p><p style="">fi</p><p style="">```</p><p style="">#### 9）编写脚本:提示用户输入用户名和密码,脚本自动创建相应的账户及配置密码。如果用户不输入账户名,则提示必须输入账户名并退出脚本;如果用户不输入密码,则统一使用默认的 123456 作为默认密码。</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写脚本:提示用户输入用户名和密码,脚本自动创建相应的账户及配置密码。如果用户</p><p style=""># 不输入账户名,则提示必须输入账户名并退出脚本;如果用户不输入密码,则统一使用默</p><p style=""># 认的 123456 作为默认密码。</p><p style="">read -p "请输入用户名: " user</p><p style="">[[使用]]‐z 可以判断一个变量是否为空,如果为空,提示用户必须输入账户名,并退出脚本,退出码为 2</p><p style="">[[没有输入用户名脚本退出后]],使用$?查看的返回码为 2</p><p style="">if [ -z $user ];then</p><p style="">     echo "您不需输入账户名"</p><p style="">   exit 2</p><p style="">fi</p><p style="">[[使用]] stty ‐echo 关闭 shell 的回显功能</p><p style="">[[使用]] stty  echo 打开 shell 的回显功能</p><p style="">stty -echo</p><p style="">read -p "请输入密码: " pass</p><p style="">stty echo</p><p style="">pass=${pass:‐123456}</p><p style="">useradd "$user"</p><p style="">echo "$pass" | passwd ‐‐stdin "$user"</p><p style="">```</p><p style="">#### 10）输入三个数并进行升序排序</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 依次提示用户输入 3 个整数,脚本根据数字大小依次排序输出 3 个数字</p><p style="">read -p "请输入一个整数:" num1</p><p style="">read -p "请输入一个整数:" num2</p><p style="">read -p "请输入一个整数:" num3</p><p style=""># 不管谁大谁小,最后都打印 echo "$num1,$num2,$num3"</p><p style=""># num1 中永远存最小的值,num2 中永远存中间值,num3 永远存最大值</p><p style=""># 如果输入的不是这样的顺序,则改变数的存储顺序,如:可以将 num1 和 num2 的值对调</p><p style="">tmp=0</p><p style=""># 如果 num1 大于 num2,就把 num1 和和 num2 的值对调,确保 num1 变量中存的是最小值</p><p style="">if [ $num1 -gt $num2 ];then   </p><p style="">  tmp=$num1</p><p style="">  num1=$num2</p><p style="">  num2=$tmp</p><p style="">fi</p><p style=""># 如果 num1 大于 num3,就把 num1 和 num3 对调,确保 num1 变量中存的是最小值</p><p style="">if [ $num1 -gt $num3 ];then   </p><p style="">    tmp=$num1</p><p style="">    num1=$num3</p><p style="">    num3=$tmp</p><p style="">fi</p><p style=""># 如果 num2 大于 num3,就把 num2 和 num3 对标,确保 num2 变量中存的是小一点的值</p><p style="">if [ $num2 -gt $num3 ];then</p><p style="">    tmp=$num2</p><p style="">    num2=$num3</p><p style="">    num3=$tmp</p><p style="">fi</p><p style="">echo "排序后数据(从小到大)为:$num1,$num2,$num3"</p><p style="">```</p><p style="">#### 11）石头、剪刀、布游戏</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写脚本,实现人机&lt;石头,剪刀,布&gt;游戏</p><p style="">game=(石头 剪刀 布)</p><p style="">num=$[RANDOM%3]</p><p style="">computer=${game[$num]}</p><p style=""># 通过随机数获取计算机的出拳</p><p style=""># 出拳的可能性保存在一个数组中,game[0],game[1],game[2]分别是 3 中不同的可能</p><p style="">echo "请根据下列提示选择您的出拳手势"</p><p style="">echo "1.石头"</p><p style="">echo "2.剪刀"</p><p style="">echo "3.布"</p><p style="">read -p "请选择 1‐3:" person</p><p style="">case  $person  in</p><p style="">1)</p><p style="">  if [ $num -eq 0 ]</p><p style="">  then</p><p style="">    echo "平局"</p><p style="">    elif [ $num -eq 1 ]</p><p style="">    then</p><p style="">      echo "你赢"</p><p style="">  else</p><p style="">    echo "计算机赢"</p><p style="">  fi;;</p><p style="">2)   </p><p style="">  if [ $num -eq 0 ]</p><p style="">  then</p><p style="">    echo "计算机赢"</p><p style="">    elif [ $num -eq 1 ]</p><p style="">    then</p><p style="">      echo "平局"</p><p style="">  else</p><p style="">    echo "你赢"</p><p style="">  fi;;</p><p style="">3)</p><p style="">  if [ $num -eq 0 ]</p><p style="">  then</p><p style="">    echo "你赢"</p><p style="">    elif [ $num -eq 1 ]</p><p style="">    then</p><p style="">      echo "计算机赢"</p><p style="">  else</p><p style="">    echo "平局"</p><p style="">  fi;;</p><p style="">*)</p><p style="">  echo "必须输入 1‐3 的数字"</p><p style="">esac</p><p style="">```</p><p style="">#### 12）编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(for 版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机</p><p style=""># 状态(for 版本)</p><p style="">for i in {1..254}</p><p style="">do</p><p style="">  # 每隔0.3秒ping一次，一共ping2次，并以1毫秒为单位设置ping的超时时间</p><p style="">     ping ‐c 2 ‐i 0.3 ‐W 1 192.168.4.$i  &amp;&gt;/dev/null</p><p style="">    if  [ $? -eq 0 ];then</p><p style="">         echo "192.168.4.$i is up"</p><p style="">     else</p><p style="">         echo  "192.168.4.$i is down"</p><p style="">     fi</p><p style="">done</p><p style="">```</p><p style="">#### 13）编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(while 版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机</p><p style=""># 状态(while 版本) </p><p style="">i=1</p><p style="">while [ $i -le 254 ]</p><p style="">do</p><p style="">     ping ‐c 2 ‐i 0.3 ‐W 1 192.168.4.$i  &amp;&gt;/dev/null</p><p style="">     if  [ $? -eq 0 ];then</p><p style="">         echo "192.168.4.$i is up"</p><p style="">    else</p><p style="">         echo  "192.168.4.$i is down"</p><p style="">     fi</p><p style="">     let i++</p><p style="">done</p><p style="">```</p><p style="">#### 14）编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(多进程版)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机</p><p style=""># 状态(多进程版)</p><p style="">[[定义一个函数]],ping 某一台主机,并检测主机的存活状态</p><p style="">myping(){</p><p style="">ping ‐c 2 ‐i 0.3 ‐W 1 $1  &amp;&gt;/dev/null</p><p style="">if  [ $? -eq 0 ];then</p><p style="">  echo "$1 is up"</p><p style="">else</p><p style="">  echo "$1 is down"</p><p style="">fi</p><p style="">}</p><p style="">for i in {1..254}</p><p style="">do</p><p style="">     myping 192.168.4.$i &amp;</p><p style="">done</p><p style=""># 使用&amp;符号,将执行的函数放入后台执行</p><p style=""># 这样做的好处是不需要等待ping第一台主机的回应,就可以继续并发ping第二台主机,依次类推。</p><p style="">```</p><p style="">#### 15）编写脚本,显示进度条</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写脚本,显示进度条</p><p style="">jindu(){</p><p style="">while :</p><p style="">do</p><p style="">     echo -n '#'</p><p style="">     sleep 0.2</p><p style="">done</p><p style="">}</p><p style="">jindu &amp;</p><p style="">cp -a $1 $2</p><p style="">killall $0</p><p style="">echo "拷贝完成"</p><p style="">```</p><p style="">#### 16）进度条,动态时针版本；定义一个显示进度的函数,屏幕快速显示|  / ‐ \</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 进度条,动态时针版本</p><p style=""># 定义一个显示进度的函数,屏幕快速显示|  / ‐ \</p><p style="">rotate_line(){</p><p style="">INTERVAL=0.5  [[设置间隔时间]]</p><p style="">COUNT="0"     [[设置4个形状的编号]],默认编号为 0(不代表任何图像)</p><p style="">while :</p><p style="">do</p><p style="">  COUNT<code>expr $COUNT + 1</code> [[执行循环]],COUNT 每次循环加 1,(分别代表4种不同的形状)</p><p style="">  case $COUNT in          [[判断]] COUNT 的值,值不一样显示的形状就不一样</p><p style="">  "1")                    [[值为]] 1 显示‐</p><p style="">          echo -e '‐'"\b\c"</p><p style="">          sleep $INTERVAL</p><p style="">          ;;</p><p style="">    "2")                  [[值为]] 2 显示\\,第一个\是转义</p><p style="">          echo -e '\\'"\b\c"</p><p style="">          sleep $INTERVAL</p><p style="">          ;;</p><p style="">    "3")                  [[值为]] 3 显示|</p><p style="">          echo -e "|\b\c"</p><p style="">          sleep $INTERVAL</p><p style="">          ;;</p><p style="">   "4")                   [[值为]] 4 显示/</p><p style="">          echo -e "/\b\c"</p><p style="">          sleep $INTERVAL</p><p style="">          ;;</p><p style="">    *)                    [[值为其他时]],将 COUNT 重置为 0</p><p style="">          COUNT="0";;</p><p style="">    esac</p><p style="">done</p><p style="">}</p><p style="">rotate_line</p><p style="">```</p><p style="">#### 17）9*9 乘法表</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 9*9 乘法表(编写 shell 脚本,打印 9*9 乘法表) </p><p style="">for i in <code>seq 9</code></p><p style="">do</p><p style="">    for j in <code>seq $i</code></p><p style="">     do</p><p style="">         echo -n "$j*$i=$[i*j]  "</p><p style="">     done</p><p style="">    echo</p><p style="">done</p><p style="">```</p><p style="">#### 18）使用死循环实时显示 eth0 网卡发送的数据包流量</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用死循环实时显示 eth0 网卡发送的数据包流量 </p><p style="">while :</p><p style="">do</p><p style="">   echo  '本地网卡 eth0 流量信息如下: '</p><p style="">    ifconfig eth0 | grep "RX pack" | awk '{print $5}'</p><p style="">    ifconfig eth0 | grep "TX pack" | awk '{print $5}'</p><p style="">     sleep 1</p><p style="">done</p><p style="">```</p><p style="">#### 19）使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码本脚本执行,需要提前准备一个 user.txt 文件,该文件中包含有若干用户名信息</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码</p><p style=""># 本脚本执行,需要提前准备一个 user.txt 文件,该文件中包含有若干用户名信息</p><p style="">for i in <code>cat user.txt</code></p><p style="">do</p><p style="">     useradd  $i</p><p style="">     echo "123456" | passwd ‐‐stdin $i</p><p style="">done</p><p style="">```</p><p style="">#### 20）编写批量修改扩展名脚本</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写批量修改扩展名脚本,如批量将 txt 文件修改为 doc 文件 </p><p style=""># 执行脚本时,需要给脚本添加位置参数</p><p style=""># 脚本名  txt  doc(可以将 txt 的扩展名修改为 doc)</p><p style=""># 脚本名  doc  jpg(可以将 doc 的扩展名修改为 jpg)</p><p style="">for i in <code>ls *.$1</code></p><p style="">do</p><p style="">     mv $i ${i%.*}.$2</p><p style="">done</p><p style="">```</p><p style="">#### 21）使用 expect 工具自动交互密码远程其他主机安装 httpd 软件</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用 expect 工具自动交互密码远程其他主机安装 httpd 软件 </p><p style=""># 删除~/.ssh/known_hosts 后,ssh 远程任何主机都会询问是否确认要连接该主机</p><p style="">rm  ‐rf  ~/.ssh/known_hosts</p><p style="">expect &lt;&lt;EOF</p><p style="">spawn ssh 192.168.4.254</p><p style="">expect "yes/no" {send "yes\r"}</p><p style=""># 根据自己的实际情况将密码修改为真实的密码字串</p><p style="">expect "password" {send  "密码\r"}</p><p style="">expect "#" {send  "yum ‐y install httpd\r"}</p><p style="">expect "#" {send  "exit\r"}</p><p style="">EOF</p><p style="">```</p><p style="">#### 22）一键部署 LNMP(源码安装版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 一键部署 LNMP(源码安装版本)</p><p style="">menu()</p><p style="">{</p><p style="">clear</p><p style="">echo "  ##############‐‐‐‐Menu‐‐‐‐##############"</p><p style="">echo "# 1. Install Nginx"</p><p style="">echo "# 2. Install MySQL"</p><p style="">echo "# 3. Install PHP"</p><p style="">echo "# 4. Exit Program"</p><p style="">echo "  ########################################"</p><p style="">}</p><p style="">choice()</p><p style="">{</p><p style="">  read -p "Please choice a menu[1‐9]:" select</p><p style="">}</p><p style="">install_nginx()</p><p style="">{</p><p style="">  id nginx &amp;&gt;/dev/null</p><p style="">  if [ $? -ne 0 ];then</p><p style="">    useradd -s /sbin/nologin nginx</p><p style="">  fi</p><p style="">  if [ -f nginx‐1.8.0.tar.gz ];then</p><p style="">    tar -xf nginx‐1.8.0.tar.gz</p><p style="">    cd nginx‐1.8.0</p><p style="">    yum -y install  gcc pcre‐devel openssl‐devel zlib‐devel make</p><p style="">    ./configure ‐‐prefix=/usr/local/nginx ‐‐with‐http_ssl_module</p><p style="">    make</p><p style="">    make install</p><p style="">    ln -s /usr/local/nginx/sbin/nginx /usr/sbin/</p><p style="">    cd ..</p><p style="">  else</p><p style="">    echo "没有 Nginx 源码包"</p><p style="">  fi</p><p style="">}</p><p style="">install_mysql()</p><p style="">{</p><p style="">  yum -y install gcc gcc‐c++ cmake ncurses‐devel perl</p><p style="">  id mysql &amp;&gt;/dev/null</p><p style="">  if [ $? -ne 0 ];then</p><p style="">    useradd -s /sbin/nologin mysql</p><p style="">  fi</p><p style="">  if [ -f mysql‐5.6.25.tar.gz ];then</p><p style="">    tar -xf mysql‐5.6.25.tar.gz</p><p style="">    cd mysql‐5.6.25</p><p style="">    cmake .</p><p style="">    make</p><p style="">    make install</p><p style="">    /usr/local/mysql/scripts/mysql_install_db ‐‐user=mysql ‐‐datadir=/usr/local/mysql/data/</p><p style="">‐‐basedir=/usr/local/mysql/</p><p style="">    chown -R root.mysql /usr/local/mysql</p><p style="">    chown -R mysql /usr/local/mysql/data</p><p style="">    /bin/cp -f /usr/local/mysql/support‐files/mysql.server /etc/init.d/mysqld</p><p style="">    chmod +x /etc/init.d/mysqld</p><p style="">    /bin/cp -f /usr/local/mysql/support‐files/my‐default.cnf /etc/my.cnf</p><p style="">    echo "/usr/local/mysql/lib/" &gt;&gt; /etc/ld.so.conf</p><p style="">    ldconfig</p><p style="">    echo 'PATH=\$PATH:/usr/local/mysql/bin/' &gt;&gt; /etc/profile</p><p style="">    export PATH</p><p style="">  else</p><p style="">    echo  "没有 mysql 源码包"</p><p style="">    exit</p><p style="">  fi</p><p style="">}</p><p style="">install_php()</p><p style="">{</p><p style="">[[安装]] php 时没有指定启动哪些模块功能,如果的用户可以根据实际情况自行添加额外功能如‐‐with‐gd 等</p><p style="">yum  -y  install  gcc  libxml2‐devel</p><p style="">if [ -f mhash‐0.9.9.9.tar.gz ];then</p><p style="">  tar -xf mhash‐0.9.9.9.tar.gz</p><p style="">  cd mhash‐0.9.9.9</p><p style="">  ./configure</p><p style="">  make</p><p style="">  make install</p><p style="">  cd ..</p><p style="">if [ ! ‐f /usr/lib/libmhash.so ];then</p><p style="">  ln -s /usr/local/lib/libmhash.so /usr/lib/</p><p style="">fi</p><p style="">ldconfig</p><p style="">else</p><p style="">  echo "没有 mhash 源码包文件"</p><p style="">  exit</p><p style="">fi</p><p style="">if [ -f libmcrypt‐2.5.8.tar.gz ];then</p><p style="">  tar -xf libmcrypt‐2.5.8.tar.gz</p><p style="">  cd libmcrypt‐2.5.8</p><p style="">  ./configure</p><p style="">  make</p><p style="">  make install</p><p style="">  cd ..</p><p style="">  if [ ! -f /usr/lib/libmcrypt.so ];then  </p><p style="">    ln -s /usr/local/lib/libmcrypt.so /usr/lib/</p><p style="">  fi</p><p style="">  ldconfig</p><p style="">else</p><p style="">  echo "没有 libmcrypt 源码包文件"</p><p style="">  exit</p><p style="">fi</p><p style="">if [ -f php‐5.4.24.tar.gz ];then</p><p style="">  tar -xf php‐5.4.24.tar.gz</p><p style="">  cd php‐5.4.24</p><p style="">  ./configure  ‐‐prefix=/usr/local/php5  ‐‐with‐mysql=/usr/local/mysql  ‐‐enable‐fpm    ‐‐</p><p style="">  enable‐mbstring  ‐‐with‐mcrypt  ‐‐with‐mhash  ‐‐with‐config‐file‐path=/usr/local/php5/etc  ‐‐with‐</p><p style="">  mysqli=/usr/local/mysql/bin/mysql_config</p><p style="">  make &amp;&amp; make install</p><p style="">  /bin/cp -f php.ini‐production /usr/local/php5/etc/php.ini</p><p style="">  /bin/cp -f /usr/local/php5/etc/php‐fpm.conf.default /usr/local/php5/etc/php‐fpm.conf</p><p style="">  cd ..</p><p style="">else</p><p style="">  echo "没有 php 源码包文件"</p><p style="">  exit</p><p style="">fi </p><p style="">}</p><p style="">while :</p><p style="">do</p><p style="">  menu</p><p style="">  choice</p><p style="">  case $select in</p><p style="">  1)</p><p style="">    install_nginx</p><p style="">    ;;</p><p style="">  2)</p><p style="">    install_mysql</p><p style="">    ;;</p><p style="">  3)</p><p style="">    install_php</p><p style="">    ;;</p><p style="">  4)</p><p style="">    exit</p><p style="">    ;;</p><p style="">  *)</p><p style="">    echo Sorry!</p><p style="">  esac</p><p style="">done</p><p style="">```</p><p style="">#### 23）编写脚本快速克隆 KVM 虚拟机</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写脚本快速克隆 KVM 虚拟机</p><p style=""># 本脚本针对 RHEL7.2 或 Centos7.2</p><p style=""># 本脚本需要提前准备一个 qcow2 格式的虚拟机模板,</p><p style=""># 名称为/var/lib/libvirt/images  /.rh7_template 的虚拟机模板</p><p style=""># 该脚本使用 qemu‐img 命令快速创建快照虚拟机</p><p style=""># 脚本使用 sed 修改模板虚拟机的配置文件,将虚拟机名称、UUID、磁盘文件名、MAC 地址</p><p style=""># exit code:  </p><p style="">#    65 ‐&gt; user input nothing</p><p style="">#    66 ‐&gt; user input is not a number</p><p style="">#    67 ‐&gt; user input out of range</p><p style="">#    68 ‐&gt; vm disk image exists</p><p style="">IMG_DIR=/var/lib/libvirt/images</p><p style="">BASEVM=rh7_template</p><p style="">read -p "Enter VM number: " VMNUM</p><p style="">if [ $VMNUM -le 9 ];then</p><p style="">VMNUM=0$VMNUM</p><p style="">fi</p><p style="">if [ -z "${VMNUM}" ]; then</p><p style="">    echo "You must input a number."</p><p style="">    exit 65</p><p style="">elif [[  ${VMNUM} =~ [a‐z]  ]; then</p><p style="">    echo "You must input a number."</p><p style="">    exit 66</p><p style="">elif [ ${VMNUM} -lt 1 -o ${VMNUM} -gt 99 ]; then</p><p style="">    echo "Input out of range"</p><p style="">    exit 67</p><p style="">fi</p><p style="">NEWVM=rh7_node${VMNUM}</p><p style="">if [ -e $IMG_DIR/${NEWVM}.img ]; then</p><p style="">    echo "File exists."</p><p style="">    exit 68</p><p style="">fi</p><p style="">echo -en "Creating Virtual Machine disk image......\t"</p><p style="">qemu‐img create -f qcow2 ‐b $IMG_DIR/.${BASEVM}.img $IMG_DIR/${NEWVM}.img &amp;&gt; /dev/null</p><p style="">echo -e "\e[32;1m[OK]\e[0m"</p><p style="">[[virsh]] dumpxml ${BASEVM} &gt; /tmp/myvm.xml</p><p style="">cat /var/lib/libvirt/images/.rhel7.xml &gt; /tmp/myvm.xml</p><p style="">sed -i "/&lt;name&gt;${BASEVM}/s/${BASEVM}/${NEWVM}/" /tmp/myvm.xml</p><p style="">sed -i "/uuid/s/&lt;uuid&gt;.*&lt;\/uuid&gt;/&lt;uuid&gt;$(uuidgen)&lt;\/uuid&gt;/" /tmp/myvm.xml</p><p style="">sed -i "/${BASEVM}\.img/s/${BASEVM}/${NEWVM}/" /tmp/myvm.xml</p><p style=""># 修改 MAC 地址,本例使用的是常量,每位使用该脚本的用户需要根据实际情况修改这些值 </p><p style=""># 最好这里可以使用便利,这样更适合于批量操作,可以克隆更多虚拟机 </p><p style="">sed -i "/mac /s/a1/0c/" /tmp/myvm.xml</p><p style="">echo -en "Defining new virtual machine......\t\t"</p><p style="">virsh define /tmp/myvm.xml &amp;&gt; /dev/null</p><p style="">echo -e "\e[32;1m[OK]\e[0m"</p><p style="">```</p><p style="">#### 24）点名器脚本</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写一个点名器脚本</p><p style=""># 该脚本,需要提前准备一个 user.txt 文件</p><p style=""># 该文件中需要包含所有姓名的信息,一行一个姓名,脚本每次随机显示一个姓名</p><p style="">while :</p><p style="">do</p><p style="">[[统计]] user 文件中有多少用户</p><p style="">line<code>cat user.txt |wc ‐l</code></p><p style="">num=$[RANDOM%line+1]</p><p style="">sed -n "${num}p"  user.txt</p><p style="">sleep 0.2</p><p style="">clear</p><p style="">done</p><p style="">```</p><p style="">#### 25）查看有多少远程的 IP 在连接本机</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 查看有多少远程的 IP 在连接本机(不管是通过 ssh 还是 web 还是 ftp 都统计) </p><p style=""># 使用 netstat ‐atn 可以查看本机所有连接的状态,‐a 查看所有,</p><p style=""># -t仅显示 tcp 连接的信息,‐n 数字格式显示</p><p style=""># Local Address(第四列是本机的 IP 和端口信息)</p><p style=""># Foreign Address(第五列是远程主机的 IP 和端口信息)</p><p style=""># 使用 awk 命令仅显示第 5 列数据,再显示第 1 列 IP 地址的信息</p><p style=""># sort 可以按数字大小排序,最后使用 uniq 将多余重复的删除,并统计重复的次数</p><p style="">netstat -atn  |  awk  '{print $5}'  | awk  '{print $1}' | sort -nr  |  uniq -c</p><p style="">```</p><p style="">#### 26）对 100 以内的所有正整数相加求和(1+2+3+4…+100)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 对 100 以内的所有正整数相加求和(1+2+3+4...+100)</p><p style="">[[seq]] 100 可以快速自动生成 100 个整数</p><p style="">sum=0</p><p style="">for i in <code>seq 100</code></p><p style="">do</p><p style="">    sum=$[sum+i]</p><p style="">done</p><p style="">echo "总和是:$sum"</p><p style="">```</p><p style="">#### 27）统计 13:30 到 14:30 所有访问 apache 服务器的请求有多少个</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 统计 13:30 到 14:30 所有访问 apache 服务器的请求有多少个</p><p style=""># awk 使用‐F 选项指定文件内容的分隔符是/或者:</p><p style=""># 条件判断$7:$8 大于等于 13:30,并且要求,$7:$8 小于等于 14:30</p><p style=""># 最后使用 wc ‐l 统计这样的数据有多少行,即多少个</p><p style="">awk -F "[ /:]" '$7":"$8&gt;="13:30" &amp;&amp; $7":"$8&lt;="14:30"' /var/log/httpd/access_log |wc -l</p><p style="">```</p><p style="">#### 28）统计 13:30 到 14:30 所有访问本机 Aapche 服务器的远程 IP 地址是什么</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 统计 13:30 到 14:30 所有访问本机 Aapche 服务器的远程 IP 地址是什么 </p><p style=""># awk 使用‐F 选项指定文件内容的分隔符是/或者:</p><p style=""># 条件判断$7:$8 大于等于 13:30,并且要求,$7:$8 小于等于 14:30</p><p style=""># 日志文档内容里面,第 1 列是远程主机的 IP 地址,使用 awk 单独显示第 1 列即可</p><p style="">awk -F "[ /:]" '$7":"$8&gt;="13:30" &amp;&amp; $7":"$8&lt;="14:30"{print $1}' /var/log/httpd/access_log</p><p style="">```</p><p style="">#### 29）打印国际象棋棋盘</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 打印国际象棋棋盘</p><p style=""># 设置两个变量,i 和 j,一个代表行,一个代表列,国际象棋为 8*8 棋盘</p><p style=""># i=1 是代表准备打印第一行棋盘,第 1 行棋盘有灰色和蓝色间隔输出,总共为 8 列</p><p style=""># i=1,j=1 代表第 1 行的第 1 列;i=2,j=3 代表第 2 行的第 3 列</p><p style=""># 棋盘的规律是 i+j 如果是偶数,就打印蓝色色块,如果是奇数就打印灰色色块</p><p style=""># 使用 echo ‐ne 打印色块,并且打印完成色块后不自动换行,在同一行继续输出其他色块</p><p style="">for i in {1..8}</p><p style="">do</p><p style="">    for j in {1..8}</p><p style="">    do</p><p style="">      sum=$[i+j]</p><p style="">    if [  $[sum%2] -eq 0 ];then</p><p style="">       echo -ne "\033[46m  \033[0m"</p><p style="">    else</p><p style="">      echo -ne "\033[47m  \033[0m"</p><p style="">    fi</p><p style="">    done</p><p style="">    echo</p><p style="">done</p><p style="">```</p><p style="">#### 30）统计每个远程 IP 访问了本机 apache 几次?</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 统计每个远程 IP 访问了本机 apache 几次? </p><p style="">awk  '{ip[$1]++}END{for(i in ip){print ip[i],i}}'  /var/log/httpd/access_log</p><p style="">```</p><p style="">#### 31）统计当前 Linux 系统中可以登录计算机的账户有多少个</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 统计当前 Linux 系统中可以登录计算机的账户有多少个</p><p style="">[[方法]] 1:</p><p style="">grep "bash$" /etc/passwd | wc -l</p><p style="">[[方法]] 2:</p><p style="">awk -f: '/bash$/{x++}end{print x}'  /etc/passwd</p><p style="">```</p><p style="">#### 32）统计/var/log 有多少个文件,并显示这些文件名</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 统计/var/log 有多少个文件,并显示这些文件名 </p><p style=""># 使用 ls 递归显示所有,再判断是否为文件,如果是文件则计数器加 1</p><p style="">cd  /var/log</p><p style="">sum=0</p><p style="">for i in <code>ls -r *</code></p><p style="">do</p><p style="">   if [ -f $i ];then</p><p style="">       let sum++</p><p style="">         echo "文件名:$i"</p><p style="">     fi</p><p style="">done</p><p style="">echo "总文件数量为:$sum"</p><p style="">```</p><p style="">#### 33）自动为其他脚本添加解释器信息</p><p style="">```bash</p><p style="">Docker+K8s+Jenkins 主流技术全解视频资料【干货免费分享】</p><p style="">#!/bin/bash</p><p style=""># 自动为其他脚本添加解释器信息#!/bin/bash,如脚本名为 test.sh 则效果如下: </p><p style=""># ./test.sh  abc.sh  自动为 abc.sh 添加解释器信息</p><p style=""># ./test.sh  user.sh  自动为 user.sh 添加解释器信息</p><p style=""># 先使用 grep 判断对象脚本是否已经有解释器信息,如果没有则使用 sed 添加解释器以及描述信息</p><p style="">if  !  grep  -q  "^#!"  $1; then</p><p style="">sed  '1i #!/bin/bash'  $1</p><p style="">sed  '2i [[Description]]: '</p><p style="">fi</p><p style=""># 因为每个脚本的功能不同,作用不同,所以在给对象脚本添加完解释器信息,以及 Description 后还希望</p><p style=""># 继续编辑具体的脚本功能的描述信息,这里直接使用 vim 把对象脚本打开,并且光标跳转到该文件的第 2 行</p><p style="">vim +2 $1</p><p style="">```</p><p style="">#### 34）自动化部署 varnish 源码包软件</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 自动化部署 varnish 源码包软件 </p><p style=""># 本脚本需要提前下载 varnish‐3.0.6.tar.gz 这样一个源码包软件,该脚本即可用自动源码安装部署软件</p><p style="">yum -y install gcc readline‐devel pcre‐devel</p><p style="">useradd -s /sbin/nologin varnish</p><p style="">tar -xf varnish‐3.0.6.tar.gz</p><p style="">cd varnish‐3.0.6</p><p style=""># 使用 configure,make,make install 源码安装软件包</p><p style="">./configure ‐‐prefix=/usr/local/varnish</p><p style="">make &amp;&amp; make install</p><p style=""># 在源码包目录下,将相应的配置文件拷贝到 Linux 系统文件系统中</p><p style=""># 默认安装完成后,不会自动拷贝或安装配置文件到 Linux 系统,所以需要手动 cp 复制配置文件</p><p style=""># 并使用 uuidgen 生成一个随机密钥的配置文件</p><p style="">cp redhat/varnish.initrc /etc/init.d/varnish</p><p style="">cp redhat/varnish.sysconfig /etc/sysconfig/varnish</p><p style="">cp redhat/varnish_reload_vcl /usr/bin/</p><p style="">ln -s /usr/local/varnish/sbin/varnishd /usr/sbin/</p><p style="">ln -s /usr/local/varnish/bin/* /usr/bin</p><p style="">mkdir /etc/varnish</p><p style="">cp /usr/local/varnish/etc/varnish/default.vcl /etc/varnish/</p><p style="">uuidgen &gt; /etc/varnish/secret</p><p style="">```</p><p style="">#### 35）编写 nginx 启动脚本</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 编写 nginx 启动脚本 </p><p style=""># 本脚本编写完成后,放置在/etc/init.d/目录下,就可以被 Linux 系统自动识别到该脚本</p><p style=""># 如果本脚本名为/etc/init.d/nginx,则 service nginx start 就可以启动该服务</p><p style=""># service nginx stop 就可以关闭服务</p><p style=""># service nginx restart 可以重启服务</p><p style=""># service nginx status 可以查看服务状态</p><p style="">program=/usr/local/nginx/sbin/nginx</p><p style="">pid=/usr/local/nginx/logs/nginx.pid</p><p style="">start(){</p><p style="">if [ -f $pid ];then</p><p style="">  echo  "nginx 服务已经处于开启状态"</p><p style="">else</p><p style="">  $program</p><p style="">fi</p><p style="">stop(){</p><p style="">if [ -! -f $pid ];then</p><p style="">  echo "nginx 服务已经关闭"</p><p style="">else</p><p style="">  $program -s stop</p><p style="">  echo "关闭服务 ok"</p><p style="">fi</p><p style="">}</p><p style="">status(){</p><p style="">if [ -f $pid ];then</p><p style="">  echo "服务正在运行..."</p><p style="">else</p><p style="">  echo "服务已经关闭"</p><p style="">fi</p><p style="">}</p><p style="">case $1 in</p><p style="">start)</p><p style="">  start;;</p><p style="">stop)</p><p style="">  stop;;</p><p style="">restart)</p><p style="">  stop</p><p style="">  sleep 1</p><p style="">  start;;</p><p style="">status)</p><p style="">  status;;</p><p style="">*)</p><p style="">  echo  "你输入的语法格式错误"</p><p style="">esac</p><p style="">```</p><p style="">#### 36）自动对磁盘分区、格式化、挂载</p><p style="">```bash</p><p style=""> #!/bin/bash</p><p style=""># 自动对磁盘分区、格式化、挂载</p><p style=""># 对虚拟机的 vdb 磁盘进行分区格式化,使用&lt;&lt;将需要的分区指令导入给程序 fdisk</p><p style=""># n(新建分区),p(创建主分区),1(分区编号为 1),两个空白行(两个回车,相当于将整个磁盘分一个区)</p><p style=""># 注意:1 后面的两个回车(空白行)是必须的!</p><p style="">fdisk /dev/vdb &lt;&lt; EOF</p><p style="">n</p><p style="">p</p><p style="">1</p><p style="">wq</p><p style="">EOF</p><p style="">[[格式化刚刚创建好的分区]]</p><p style="">mkfs.xfs   /dev/vdb1</p><p style="">[[创建挂载点目录]]</p><p style="">if [ -e /data ]; then</p><p style="">exit</p><p style="">fi</p><p style="">mkdir /data</p><p style="">[[自动挂载刚刚创建的分区]],并设置开机自动挂载该分区</p><p style="">echo '/dev/vdb1     /data    xfs    defaults        1 2'  &gt;&gt; /etc/fstab</p><p style="">mount -a</p><p style="">```</p><p style="">#### 37）自动优化 Linux 内核参数</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 自动优化 Linux 内核参数</p><p style="">[[脚本针对]] RHEL7</p><p style="">cat &gt;&gt; /usr/lib/sysctl.d/00‐system.conf &lt;&lt;EOF</p><p style="">fs.file‐max=65535</p><p style="">net.ipv4.tcp_timestamps = 0</p><p style="">net.ipv4.tcp_synack_retries = 5</p><p style="">net.ipv4.tcp_syn_retries = 5</p><p style="">net.ipv4.tcp_tw_recycle = 1</p><p style="">net.ipv4.tcp_tw_reuse = 1</p><p style="">net.ipv4.tcp_fin_timeout = 30</p><p style="">[[net]].ipv4.tcp_keepalive_time = 120</p><p style="">net.ipv4.ip_local_port_range = 1024  65535</p><p style="">kernel.shmall = 2097152</p><p style="">kernel.shmmax = 2147483648</p><p style="">kernel.shmmni = 4096</p><p style="">kernel.sem = 5010 641280 5010 128</p><p style="">net.core.wmem_default=262144</p><p style="">net.core.wmem_max=262144</p><p style="">net.core.rmem_default=4194304</p><p style="">net.core.rmem_max=4194304</p><p style="">net.ipv4.tcp_fin_timeout = 10</p><p style="">net.ipv4.tcp_keepalive_time = 30</p><p style="">net.ipv4.tcp_window_scaling = 0</p><p style="">net.ipv4.tcp_sack = 0</p><p style="">EOF</p><p style="">sysctl –p</p><p style="">```</p><p style="">#### 38）切割 Nginx 日志文件(防止单个文件过大,后期处理很困难)</p><p style="">```bash</p><p style="">[[mkdir]]  /data/scripts</p><p style="">[[vim]]   /data/scripts/nginx_log.sh  </p><p style="">#!/bin/bash</p><p style=""># 切割 Nginx 日志文件(防止单个文件过大,后期处理很困难) </p><p style="">logs_path="/usr/local/nginx/logs/"</p><p style="">mv ${logs_path}access.log ${logs_path}access_$(date -d "yesterday" +"%Y%m%d").log</p><p style="">kill -USR1  <code>cat /usr/local/nginx/logs/nginx.pid</code></p><p style=""># chmod +x  /data/scripts/nginx_log.sh</p><p style=""># crontab  ‐e                    [[脚本写完后]],将脚本放入计划任务每天执行一次脚本</p><p style="">0  1  *  *   *   /data/scripts/nginx_log.sh</p><p style="">```</p><p style="">#### 39）检测 MySQL 数据库连接数量</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 检测 MySQL 数据库连接数量 </p><p style=""># 本脚本每 2 秒检测一次 MySQL 并发连接数,可以将本脚本设置为开机启动脚本,或在特定时间段执行</p><p style=""># 以满足对 MySQL 数据库的监控需求,查看 MySQL 连接是否正常</p><p style=""># 本案例中的用户名和密码需要根据实际情况修改后方可使用</p><p style="">log_file=/var/log/mysql_count.log</p><p style="">user=root</p><p style="">passwd=123456</p><p style="">while :</p><p style="">do</p><p style="">    sleep 2</p><p style="">    count<code>mysqladmin  -u  "$user"  -p  "$passwd"   status |  awk '{print $4}'</code></p><p style="">    echo <code>date +%Y‐%m‐%d</code> 并发连接数为:$count" &gt;&gt; $log_file</p><p style="">done</p><p style="">```</p><p style="">#### 40）根据 md5 校验码,检测文件是否被修改</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 根据 md5 校验码,检测文件是否被修改 </p><p style=""># 本示例脚本检测的是/etc 目录下所有的 conf 结尾的文件,根据实际情况,您可以修改为其他目录或文件</p><p style=""># 本脚本在目标数据没有被修改时执行一次,当怀疑数据被人篡改,再执行一次</p><p style=""># 将两次执行的结果做对比,MD5 码发生改变的文件,就是被人篡改的文件</p><p style="">for i in $(ls /etc/*.conf)</p><p style="">do</p><p style="">  md5sum "$i" &gt;&gt; /var/log/conf_file.log</p><p style="">done</p><p style="">```</p><p style="">#### 41）检测 MySQL 服务是否存活</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 检测 MySQL 服务是否存活 </p><p style=""># host 为你需要检测的 MySQL 主机的 IP 地址,user 为 MySQL 账户名,passwd 为密码</p><p style=""># 这些信息需要根据实际情况修改后方可使用</p><p style="">host=192.168.51.198</p><p style="">user=root</p><p style="">passwd=123456</p><p style="">mysqladmin -h '$host' -u '$user' -p'$passwd' ping &amp;&gt;/dev/null</p><p style="">if [ $? -eq 0 ]</p><p style="">then</p><p style="">        echo "MySQL is UP"</p><p style="">else</p><p style="">        echo "MySQL is down"</p><p style="">fi</p><p style="">```</p><p style="">#### 42）备份 MySQL 的 shell 脚本(mysqldump版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 备份 MySQL 的 shell 脚本(mysqldump版本) </p><p style=""># 定义变量 user(数据库用户名),passwd(数据库密码),date(备份的时间标签)</p><p style=""># dbname(需要备份的数据库名称,根据实际需求需要修改该变量的值,默认备份 mysql 数据库)</p><p style="">user=root</p><p style="">passwd=123456</p><p style="">dbname=mysql</p><p style="">date=$(date +%Y%m%d)</p><p style=""># 测试备份目录是否存在,不存在则自动创建该目录</p><p style="">[ ! -d /mysqlbackup ] &amp;&amp; mkdir /mysqlbackup</p><p style=""># 使用 mysqldump 命令备份数据库</p><p style="">mysqldump -u "$user" -p "$passwd" "$dbname" &gt; /mysqlbackup/"$dbname"-${date}.sql</p><p style="">```</p><p style="">#### 43）将文件中所有的小写字母转换为大写字母</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 将文件中所有的小写字母转换为大写字母 </p><p style=""># $1是位置参数,是你需要转换大小写字母的文件名称</p><p style=""># 执行脚本,给定一个文件名作为参数,脚本就会将该文件中所有的小写字母转换为大写字母</p><p style="">tr "[a‐z]" "[A‐Z]" &lt; $1</p><p style="">```</p><p style="">#### 44）非交互自动生成 SSH 密钥文件</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 非交互自动生成 SSH 密钥文件 </p><p style=""># ‐t 指定 SSH 密钥的算法为 RSA 算法;‐N 设置密钥的密码为空;‐f 指定生成的密钥文件&gt;存放在哪里</p><p style="">rm  -rf  ~/.ssh/{known_hosts,id_rsa*}</p><p style="">ssh‐keygen -t RSA -N '' -f ~/.ssh/id_rsa</p><p style="">```</p><p style="">#### 45）检查特定的软件包是否已经安装</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 检查特定的软件包是否已经安装 </p><p style="">if [ $# -eq 0 ];then</p><p style="">  echo "你需要制定一个软件包名称作为脚本参数"</p><p style="">  echo "用法:$0 软件包名称 ..."</p><p style="">fi</p><p style=""># $@提取所有的位置变量的值,相当于$*</p><p style="">for package in "$@"</p><p style="">do</p><p style="">    if rpm -q ${package} &amp;&gt;/dev/null ;then</p><p style="">    echo -e "${package}\033[32m 已经安装\033[0m"</p><p style="">    else</p><p style="">    echo -e "${package}\033[34;1m 未安装\033[0m"</p><p style="">    fi</p><p style="">done</p><p style="">```</p><p style="">#### 46）监控 HTTP 服务器的状态(测试返回码)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 监控 HTTP 服务器的状态(测试返回码)</p><p style=""># 设置变量,url为你需要检测的目标网站的网址(IP 或域名),比如百度</p><p style="">url=http://http://183.232.231.172/index.html</p><p style=""># 定义函数 check_http:</p><p style=""># 使用 curl 命令检查 http 服务器的状态</p><p style=""># ‐m 设置curl不管访问成功或失败,最大消耗的时间为 5 秒,5 秒连接服务为相应则视为无法连接</p><p style=""># ‐s 设置静默连接,不显示连接时的连接速度、时间消耗等信息</p><p style=""># ‐o 将 curl 下载的页面内容导出到/dev/null(默认会在屏幕显示页面内容)</p><p style=""># ‐w 设置curl命令需要显示的内容%{http_code},指定curl返回服务器的状态码</p><p style="">check_http()</p><p style="">{</p><p style="">        status_code=$(curl -m 5 -s -o /dev/null -w %{http_code} $url)</p><p style="">}</p><p style="">while :</p><p style="">do</p><p style="">        check_http</p><p style="">        date=$(date +%Y%m%d‐%H:%M:%S)</p><p style=""># 生成报警邮件的内容</p><p style="">        echo "当前时间为:$date</p><p style="">        $url 服务器异常,状态码为${status_code}.</p><p style="">        请尽快排查异常." &gt; /tmp/http$$.pid</p><p style=""># 指定测试服务器状态的函数,并根据返回码决定是发送邮件报警还是将正常信息写入日志</p><p style="">        if [ $status_code -ne 200 ];then</p><p style="">                mail -s Warning root &lt; /tmp/http$$.pid</p><p style="">        else</p><p style="">                echo "$url 连接正常" &gt;&gt; /var/log/http.log</p><p style="">        fi</p><p style="">        sleep 5</p><p style="">done</p><p style="">```</p><p style="">#### 47）自动添加防火墙规则,开启某些服务或端口(适用于 RHEL7)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 自动添加防火墙规则,开启某些服务或端口(适用于 RHEL7)</p><p style=""># </p><p style=""># 设置变量定义需要添加到防火墙规则的服务和端口号</p><p style=""># 使用 firewall‐cmd ‐‐get‐services 可以查看 firewall 支持哪些服务</p><p style="">service="nfs http ssh"</p><p style="">port="80 22 8080"</p><p style=""># 循环将每个服务添加到防火墙规则中</p><p style="">for i in $service</p><p style="">do</p><p style="">    echo "Adding $i service to firewall"</p><p style="">    firewall‐cmd  --add-service=${i}</p><p style="">done</p><p style="">[[循环将每个端口添加到防火墙规则中]]</p><p style="">for i in $port</p><p style="">do</p><p style="">    echo "Adding $i Port to firewall"</p><p style="">    firewall‐cmd --add-port=${i}/tcp</p><p style="">done</p><p style="">[[将以上设置的临时防火墙规则]],转换为永久有效的规则(确保重启后有效)</p><p style="">firewall‐cmd  --runtime-to-permanent</p><p style="">```</p><p style="">#### 48）使用脚本自动创建逻辑卷</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用脚本自动创建逻辑卷 </p><p style=""># 清屏,显示警告信息,创建将磁盘转换为逻辑卷会删除数据</p><p style="">clear</p><p style="">echo -e "\033[32m           !!!!!!警告(Warning)!!!!!!\033[0m"</p><p style="">echo</p><p style="">echo "+++++++++++++++++++++++++++++++++++++++++++++++++"</p><p style="">echo "脚本会将整个磁盘转换为 PV,并删除磁盘上所有数据!!!"</p><p style="">echo "This Script will destroy all data on the Disk"</p><p style="">echo "+++++++++++++++++++++++++++++++++++++++++++++++++"</p><p style="">echo</p><p style="">read -p "请问是否继续 y/n?:" sure</p><p style=""># 测试用户输入的是否为 y,如果不是则退出脚本</p><p style="">[ $sure != y ] &amp;&amp; exit</p><p style=""># 提示用户输入相关参数(磁盘、卷组名称等数据),并测试用户是否输入了这些值,如果没有输入,则脚本退出</p><p style="">read -p "请输入磁盘名称,如/dev/vdb:" disk</p><p style="">[ -z $disk ] &amp;&amp; echo "没有输入磁盘名称" &amp;&amp; exit</p><p style="">read -p "请输入卷组名称:" vg_name</p><p style="">[ -z $vg_name ] &amp;&amp; echo "没有输入卷组名称" &amp;&amp; exit</p><p style="">read -p "请输入逻辑卷名称:" lv_name</p><p style="">[ -z $lv_name ] &amp;&amp; echo "没有输入逻辑卷名称" &amp;&amp; exit</p><p style="">read -p "请输入逻辑卷大小:" lv_size</p><p style="">[ -z $lv_size ] &amp;&amp; echo "没有输入逻辑卷大小" &amp;&amp; exit</p><p style=""># 使用命令创建逻辑卷</p><p style="">pvcreate $disk</p><p style="">vgcreate $vg_name $disk</p><p style="">lvcreate -L ${lv_size}M -n ${lv_name}  ${vg_name}</p><p style="">```</p><p style="">#### 49）显示 CPU 厂商信息</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 显示 CPU 厂商信息 </p><p style="">awk '/vendor_id/{print $3}' /proc/cpuinfo | uniq</p><p style="">```</p><p style="">#### 50）删除某个目录下大小为 0 的文件</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 删除某个目录下大小为 0 的文件</p><p style="">[[/var/www/html]] 为测试目录,脚本会清空该目录下所有 0 字节的文件</p><p style="">dir="/var/www/html"</p><p style="">find $dir -type f -size 0 -exec rm -rf {} \;</p><p style="">```</p><p style="">#### 51）查找 Linux 系统中的僵尸进程</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 查找 Linux 系统中的僵尸进程</p><p style=""># awk 判断 ps 命令输出的第 8 列为 Z 是,显示该进程的 PID 和进程命令</p><p style="">ps aux | awk '{if($8 == "Z"){print $2,$11}}'</p><p style="">```</p><p style="">#### 52）提示用户输入年份后判断该年是否为闰年</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 提示用户输入年份后判断该年是否为闰年</p><p style=""># 能被4整除并且并不能被100整除的年份是闰年</p><p style=""># 能被400整除的年份也是闰年</p><p style="">read -p "请输入一个年份:" year</p><p style="">if [ "$year" = "" ];then</p><p style="">    echo "没有输入年份"</p><p style="">    exit</p><p style="">fi</p><p style="">[[使用正则测试变量]] year 中是否包含大小写字母</p><p style="">if [[ "$year" =~ [a‐Z] ]];then</p><p style="">    echo "你输入的不是数字"</p><p style="">    exit</p><p style="">fi</p><p style=""># 判断是否为闰年</p><p style="">if [ $[year % 4] -eq 0 ] &amp;&amp; [ $[year % 100] -ne 0 ];then</p><p style="">    echo "$year年是闰年"  </p><p style="">elif [ $[year % 400] -eq 0 ];then</p><p style="">    echo "$year年是闰年"</p><p style="">else</p><p style="">    echo "$year年不是闰年"</p><p style="">fi</p><p style="">```</p><p style="">#### 53）生成随机密码(urandom 版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 生成随机密码(urandom 版本) </p><p style=""># /dev/urandom 文件是 Linux 内置的随机设备文件</p><p style=""># cat /dev/urandom 可以看看里面的内容,ctrl+c 退出查看</p><p style=""># 查看该文件内容后,发现内容有些太随机,包括很多特殊符号,我们需要的密码不希望使用这些符号</p><p style=""># tr ‐dc '_A‐Za‐z0‐9' &lt; /dev/urandom</p><p style=""># 该命令可以将随机文件中其他的字符删除,仅保留大小写字母,数字,下划线,但是内容还是太多</p><p style=""># 我们可以继续将优化好的内容通过管道传递给 head 命令,在大量数据中仅显示头 10 个字节</p><p style=""># 注意 A 前面有个下划线</p><p style="">tr -dc '_A‐Za‐z0‐9' &lt;/dev/urandom | head -c 10</p><p style="">```</p><p style="">#### 54）生成随机密码(字串截取版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 生成随机密码(字串截取版本) </p><p style=""># 设置变量 key,存储密码的所有可能性(密码库),如果还需要其他字符请自行添加其他密码字符</p><p style=""># 使用$#统计密码库的长度</p><p style="">key="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</p><p style="">num=${#key}</p><p style=""># 设置初始密码为空</p><p style="">pass=''</p><p style=""># 循环 8 次,生成随机密码</p><p style=""># 每次都是随机数对密码库的长度取余,确保提取的密码字符不超过密码库的长度</p><p style=""># 每次循环提取一位随机密码,并将该随机密码追加到 pass 变量的最后</p><p style="">for i in {1..8}</p><p style="">do  </p><p style="">  index=$[RANDOM%num]</p><p style="">  pass=$pass${key:$index:1}</p><p style="">done</p><p style="">echo $pass</p><p style="">```</p><p style="">#### 55）生成随机密码(UUID 版本,16 进制密码)</p><p style="">```</p><p style="">#!/bin/bash</p><p style=""># 生成随机密码(UUID 版本,16 进制密码) </p><p style="">uuidgen</p><p style="">```</p><p style="">#### 56）生成随机密码(进程 ID 版本,数字密码)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 生成随机密码(进程 ID 版本,数字密码)</p><p style="">echo $$</p><p style="">```</p><p style="">#### 57）测试用户名与密码是否正确</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 测试用户名与密码是否正确</p><p style="">[[用户名为]] tom 并且密码为 123456,则提示登录成功,否则提示登录失败</p><p style="">read -p "请输入用户名:"  user</p><p style="">read -p "请输入密码:"    pass</p><p style="">if [ "$user" <mark> 'tom' -a "$pass" </mark> '123456' ];then</p><p style="">  echo "Login successful"</p><p style="">else</p><p style="">  echo "Login Failed"</p><p style="">fi</p><p style="">```</p><p style="">#### 58）循环测试用户名与密码是否正确</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 循环测试用户名与密码是否正确 </p><p style=""># 循环测试用户的账户名和密码,最大测试 3 次,输入正确提示登录成功,否则提示登录失败</p><p style=""># 用户名为 tom 并且密码为 123456  </p><p style="">for i in {1..3}</p><p style="">do</p><p style="">  read -p "请输入用户名:" user</p><p style="">  read -p "请输入密码:"   pass</p><p style="">if [ "$user" <mark> 'tom' -a "$pass" </mark> '123456' ];then</p><p style="">    echo "Login successful"</p><p style="">     exit</p><p style="">fi</p><p style="">done</p><p style="">echo "Login Failed"</p><p style="">```</p><p style="">#### 59）Shell 脚本的 fork 炸弹</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># Shell 脚本的 fork 炸弹 </p><p style=""># 快速消耗计算机资源,致使计算机死机</p><p style=""># 定义函数名为.(点), 函数中递归调用自己并放入后台执行</p><p style="">.() { .|.&amp; };.</p><p style="">```</p><p style="">#### 60）批量下载有序文件(pdf、图片、视频等等)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 批量下载有序文件(pdf、图片、视频等等)</p><p style=""># 本脚本准备有序的网络资料进行批量下载操作(如 01.jpg,02.jpg,03.jpg)</p><p style=""># 设置资源来源的域名连接</p><p style="">url="http://www.baidu.com/"</p><p style="">echo  "开始下载..."</p><p style="">sleep 2</p><p style="">type=jpg</p><p style="">for i in <code>seq 100</code></p><p style="">     echo "正在下载$i.$type"</p><p style="">  curl $url/$i.$type -o /tmp/${i}$type</p><p style="">     sleep 1</p><p style="">done</p><p style="">[[curl]] 使用-o 选项指定下载文件另存到哪里.</p><p style="">```</p><p style="">#### 61）显示当前计算机中所有账户的用户名称</p><p style="">```bash</p><p style=""> #!/bin/bash</p><p style=""> # 显示当前计算机中所有账户的用户名称</p><p style=""># 下面使用3种不同的方式列出计算机中所有账户的用户名</p><p style=""># 指定以:为分隔符,打印/etc/passwd 文件的第 1 列</p><p style="">awk -F: '{print $1}' /etc/passwd</p><p style=""># 指定以:为分隔符,打印/etc/passwd 文件的第 1 列</p><p style="">cut -d: -f1 /etc/passwd</p><p style=""># 使用 sed 的替换功能,将/etc/passwd 文件中:后面的所有内容替换为空(仅显示用户名)</p><p style="">sed 's/:.*//' /etc/passwd</p><p style="">```</p><p style="">#### 62）制定目录路径,脚本自动将该目录使用 tar 命令打包备份到/data目录</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 制定目录路径,脚本自动将该目录使用 tar 命令打包备份到/data目录 </p><p style="">[ ! -d /data ] &amp;&amp; mkdir /data</p><p style="">[ -z $1 ] &amp;&amp; exit</p><p style="">if [ -d $1 ];then</p><p style="">  tar -czf /data/$1.<code>date +%Y%m%d</code>.tar.gz $1</p><p style="">else</p><p style="">    echo "该目录不存在"</p><p style="">fi</p><p style="">```</p><p style="">#### 63）显示进度条(回旋镖版)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 显示进度条(回旋镖版)</p><p style="">while :</p><p style="">do</p><p style="">  clear</p><p style="">  for i in {1..20}</p><p style="">  do</p><p style="">    echo ‐e "\033[3;${i}H*"</p><p style="">    sleep 0.1</p><p style="">    done</p><p style="">    clear</p><p style="">    for i in {20..1}</p><p style="">    do</p><p style="">    echo ‐e "\033[3;${i}H*"</p><p style="">    sleep 0.1</p><p style="">    done</p><p style="">    clear</p><p style="">done</p><p style="">```</p><p style="">#### 64）安装 LAMP 环境(yum 版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 安装 LAMP 环境(yum 版本) </p><p style=""># 本脚本适用于 RHEL7(RHEL6 中数据库为 mysql)</p><p style="">yum makecache &amp;&gt;/dev/null</p><p style="">num=$(yum repolist | awk '/repolist/{print $2}' | sed 's/,//')</p><p style="">if [ $num -lt 0 ];then</p><p style="">  yum -y install httpd</p><p style="">  yum -y install mariadb mariadb-server mariadb-devel</p><p style="">  yum -y install php php-mysql</p><p style="">else</p><p style="">  echo "未配置 yum 源..."</p><p style="">fi</p><p style="">```</p><p style="">#### 65）循环关闭局域网中所有主机</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 循环关闭局域网中所有主机 </p><p style=""># 假设本机为 192.168.4.100,编写脚本关闭除自己外的其他所有主机</p><p style=""># 脚本执行,需要提前给所有其他主机传递 ssh 密钥,满足无密码连接</p><p style="">for i in {1..254}</p><p style="">do</p><p style="">  [ $i -eq 100 ] &amp;&amp; continue</p><p style="">  echo "正在关闭 192.168.4.$i..."</p><p style="">  ssh 192.168.4.$i poweroff</p><p style="">done</p><p style="">```</p><p style="">#### 66）获取本机 MAC 地址</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 获取本机 MAC 地址</p><p style="">ip a s | awk 'BEGIN{print  " 本 机 MAC 地 址 信 息 如 下 :"}/^[0‐9]/{print $2;getline;if($0~/link\/ether/){print $2}}' | grep -v lo:</p><p style=""># awk 读取 ip 命令的输出,输出结果中如果有以数字开始的行,先显示该行的地 2 列(网卡名称),</p><p style=""># 接着使用 getline 再读取它的下一行数据,判断是否包含 link/ether</p><p style=""># 如果保护该关键词,就显示该行的第 2 列(MAC 地址)</p><p style=""># lo 回环设备没有 MAC,因此将其屏蔽,不显示</p><p style="">```</p><p style="">#### 67）自动配置 rsynd 服务器的配置文件 rsyncd.conf</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 自动配置 rsynd 服务器的配置文件 rsyncd.conf</p><p style=""># See rsyncd.conf man page for more options.</p><p style="">[ ! -d /home/ftp ] &amp;&amp; mkdir /home/ftp</p><p style="">echo 'uid = nobody</p><p style="">gid = nobody</p><p style="">use chroot = yes</p><p style="">max connections = 4</p><p style="">pid file = /var/run/rsyncd.pid</p><p style="">exclude = lost+found/</p><p style="">transfer logging = yes</p><p style="">timeout = 900</p><p style="">ignore nonreadable = yes</p><p style="">dont compress   = <em>.gz </em>.tgz <em>.zip </em>.z <em>.Z </em>.rpm <em>.deb </em>.bz2</p><p style="">[ftp]</p><p style="">    path = /home/ftp</p><p style="">    comment = share' &gt; /etc/rsyncd.conf</p><p style="">```</p><p style="">#### 68）修改 Linux 系统的最大打开文件数量</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 修改 Linux 系统的最大打开文件数量 </p><p style=""># 往/etc/security/limits.conf 文件的末尾追加两行配置参数,修改最大打开文件数量为 65536</p><p style="">cat &gt;&gt; /etc/security/limits.conf &lt;&lt;EOF</p><p style="">* soft nofile  65536</p><p style="">* hard nofile  65536</p><p style="">EOF</p><p style="">```</p><p style="">#### 69）设置 Python 支持自动命令补齐功能</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 设置 Python 支持自动命令补齐功能 </p><p style=""># Summary:Enable tab complete for python</p><p style=""># Description:</p><p style="">Needs import readline and rlcompleter module</p><p style="">#</p><p style="">import readline</p><p style="">#</p><p style="">import rlcompleter</p><p style="">#</p><p style="">help(rlcompleter) display detail: readline.parse_and_bind('tab: complete')</p><p style="">#</p><p style="">man python display detail: PYTHONSTARTUP variable</p><p style="">if  [ ! -f /usr/bin/tab.py ];then</p><p style="">  cat &gt;&gt; /usr/bin/tab.py &lt;&lt;EOF</p><p style="">import readline</p><p style="">import rlcompleter</p><p style="">readline.parse_and_bind('tab: complete')</p><p style="">EOF</p><p style="">fi</p><p style="">sed  -i '$a export PYTHONSTARTUP=/usr/bin/tab.py' /etc/profile</p><p style="">source /etc/profile</p><p style="">```</p><p style="">#### 70）自动修改计划任务配置文件</p><p style="">```bash</p><p style="">Docker+K8s+Jenkins 主流技术全解视频资料【干货免费分享】</p><p style="">#!/bin/bash</p><p style=""># 自动修改计划任务配置文件 </p><p style="">read -p "请输入分钟信息(00‐59):" min</p><p style="">read -p "请输入小时信息(00‐24):" hour</p><p style="">read -p "请输入日期信息(01‐31):" date</p><p style="">read -p "请输入月份信息(01‐12):" month</p><p style="">read -p "请输入星期信息(00‐06):" weak</p><p style="">read -p "请输入计划任务需要执行的命令或脚本:" program</p><p style="">echo "$min $hour $date $month $weak $program" &gt;&gt; /etc/crontab</p><p style="">```</p><p style="">#### 71）使用脚本循环创建三位数字的文本文件(111-999 的文件)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用脚本循环创建三位数字的文本文件(111-999 的文件) </p><p style="">for i in {1..9}</p><p style="">do</p><p style="">  for j in {1..9}</p><p style="">  do</p><p style="">    for k in {1..9}</p><p style="">    do</p><p style="">      touch /tmp/$i$j$k.txt</p><p style="">    done</p><p style="">    done</p><p style="">done</p><p style="">```</p><p style="">#### 72）找出/etc/passwd 中能登录的用户,并将对应在/etc/shadow 中第二列密码提出处理</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 找出/etc/passwd 中能登录的用户,并将对应在/etc/shadow 中第二列密码提出处理</p><p style="">user=$(awk -F: '/bash$/{print $1}' /etc/passwd)</p><p style="">for i in $user</p><p style="">do</p><p style="">  awk -F: -v x=$i '$1==x{print $1,$2}' /etc/shadow</p><p style="">done</p><p style="">```</p><p style="">#### 73）统计/etc/passwd 中 root 出现的次数</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 统计/etc/passwd 中 root 出现的次数 </p><p style="">[[每读取一行文件内容]],即从第 1 列循环到最后 1 列,依次判断是否包含 root 关键词,如果包含则 x++</p><p style="">awk -F: '{i=1;while(i&lt;=NF){if($i~/root/){x++};i++}} END{print "root 出现次数为"x}' /etc/passwd</p><p style="">```</p><p style="">#### 74）统计 Linux 进程相关数量信息</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 统计 Linux 进程相关数量信息 </p><p style="">running=0</p><p style="">sleeping=0</p><p style="">stoped=0</p><p style="">zombie=0</p><p style=""># 在 proc 目录下所有以数字开始的都是当前计算机正在运行的进程的进程 PID</p><p style=""># 每个 PID 编号的目录下记录有该进程相关的信息</p><p style="">for pid in /proc/[1‐9]*</p><p style="">do</p><p style="">  procs=$[procs+1]</p><p style="">  stat=$(awk '{print $3}' $pid/stat)</p><p style=""># 每个 pid 目录下都有一个 stat 文件,该文件的第 3 列是该进程的状态信息</p><p style="">    case $stat in</p><p style="">    R)</p><p style="">    running=$[running+1]</p><p style="">    ;;</p><p style="">    T)</p><p style="">    stoped=$[stoped+1]</p><p style="">    ;;</p><p style="">    S)</p><p style="">    sleeping=$[sleeping+1]</p><p style="">    ;;</p><p style="">    Z)</p><p style="">     zombie=$[zombie+1]</p><p style="">     ;;</p><p style="">    esac</p><p style="">done</p><p style="">echo "进程统计信息如下"</p><p style="">echo "总进程数量为:$procs"</p><p style="">echo "Running 进程数为:$running"</p><p style="">echo "Stoped 进程数为:$stoped"</p><p style="">echo "Sleeping 进程数为:$sleeping"</p><p style="">echo "Zombie 进程数为:$zombie"</p><p style="">```</p><p style="">#### 75）从键盘读取一个论坛积分,判断论坛用户等级</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 从键盘读取一个论坛积分,判断论坛用户等级</p><p style="">[[等级分类如下]]:</p><p style="">#  大于等于 90        神功绝世</p><p style="">#  大于等于 80,小于 90       登峰造极</p><p style="">#  大于等于 70,小于 80       炉火纯青</p><p style="">#  大于等于 60,小于 70       略有小成</p><p style="">#  小于 60               初学乍练</p><p style="">read -p "请输入积分(0‐100):" JF</p><p style="">if [ $JF -ge 90 ] ; then</p><p style="">  echo "$JF 分,神功绝世"</p><p style="">elif [ $JF -ge 80 ] ; then</p><p style="">    echo "$JF 分,登峰造极"</p><p style="">elif [ $JF -ge 70 ] ; then</p><p style="">    echo "$JF 分,炉火纯青"</p><p style="">elif [ $JF -lt 60 ] ; then</p><p style="">    echo "$JF 分,略有小成"</p><p style="">else</p><p style="">    echo "$JF 分,初学乍练"</p><p style="">fi</p><p style="">```</p><p style="">#### 76）判断用户输入的数据类型(字母、数字或其他)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 判断用户输入的数据类型(字母、数字或其他) </p><p style="">read -p "请输入一个字符:" KEY</p><p style="">case "$KEY" in</p><p style="">  [a‐z]|[A‐Z])</p><p style="">    echo "字母" </p><p style="">    ;;</p><p style="">  [0‐9])</p><p style="">    echo "数字" </p><p style="">    ;;</p><p style="">  *)</p><p style="">    echo "空格、功能键或其他控制字符"</p><p style="">esac</p><p style="">```</p><p style="">#### 77）显示进度条(数字版)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 显示进度条(数字版) </p><p style=""># echo 使用‐e 选项后,在打印参数中可以指定 H,设置需要打印内容的 x,y 轴的定位坐标</p><p style=""># 设置需要打印内容在第几行,第几列</p><p style="">for i in {1..100}</p><p style="">do</p><p style="">    echo -e "\033[6;8H["</p><p style="">    echo -e "\033[6;9H$i%"</p><p style="">    echo -e "\033[6;13H]"</p><p style="">    sleep 0.1</p><p style="">done</p><p style="">```</p><p style="">#### 78）打印斐波那契数列</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 打印斐波那契数列(该数列的特点是后一个数字,永远都是前 2 个数字之和) </p><p style=""># 斐波那契数列后一个数字永远是前 2 个数字之和</p><p style=""># 如:0  1  1  2  3  5  8  13 ... ...</p><p style="">list=(0 1)</p><p style="">for i in <code>seq 2 11</code></p><p style="">do</p><p style="">  list[$i]<code>expr ${list[‐1]} + ${list[‐2]}</code></p><p style="">done</p><p style="">echo ${list[@]}</p><p style="">```</p><p style="">#### 79）判断用户输入的是 Yes 或 NO</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 判断用户输入的是 Yes 或 NO </p><p style="">read -p  "Are you sure?[y/n]:"  sure</p><p style="">case  $sure  in</p><p style="">  y|Y|Yes|YES)  </p><p style="">    echo "you enter $a"</p><p style="">    ;;</p><p style="">    n|N|NO|no)</p><p style="">     echo "you enter $a"</p><p style="">     ;;</p><p style="">    *)</p><p style="">     echo "error";;</p><p style="">esac</p><p style="">```</p><p style="">#### 80）显示本机 Linux 系统上所有开放的端口列表</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 显示本机 Linux 系统上所有开放的端口列表 </p><p style=""># 从端口列表中观测有没有没用的端口,有的话可以将该端口对应的服务关闭,防止意外的攻击可能性</p><p style="">ss -nutlp | awk '{print $1,$5}' | awk -F"[: ]" '{print "协议:"$1,"端口号:"$NF}' | grep "[0‐9]" | uniq</p><p style="">```</p><p style="">#### 81）将 Linux 系统中 UID 大于等于 1000 的普通用户都删除</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 将 Linux 系统中 UID 大于等于 1000 的普通用户都删除 </p><p style=""># 先用 awk 提取所有 uid 大于等于 1000 的普通用户名称</p><p style=""># 再使用 for 循环逐个将每个用户删除即可</p><p style="">user=$(awk -F: '$3&gt;=1000{print $1}' /etc/passwd)</p><p style="">for i in $user</p><p style="">do</p><p style="">     userdel -r $i</p><p style="">done</p><p style="">```</p><p style="">#### 82）使用脚本开启关闭虚拟机</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用脚本开启关闭虚拟机 </p><p style=""># 脚本通过调用virsh命令实现对虚拟机的管理,如果没有该命令,需要安装 libvirt‐client 软件包</p><p style=""># $1是脚本的第1个参数,$2是脚本的第2个参数</p><p style=""># 第1个参数是你希望对虚拟机进行的操作指令,第2个参数是虚拟机名称</p><p style="">case $1 in</p><p style="">  list)</p><p style="">    virsh list --all</p><p style="">    ;;</p><p style="">  start)</p><p style="">    virsh start $2</p><p style="">    ;;</p><p style="">  stop)</p><p style="">    virsh destroy $2</p><p style="">    ;;</p><p style="">  enable)</p><p style="">    virsh autostart $2</p><p style="">    ;;</p><p style="">  disable)</p><p style="">    virsh autostart --disable $2</p><p style="">    ;;</p><p style="">  *)</p><p style="">    echo "Usage:$0 list"</p><p style="">    echo "Usage:$0 [start|stop|enable|disable]  VM_name"</p><p style="">    cat &lt;&lt; EOF</p><p style="">    [[list]]      显示虚拟机列表</p><p style="">    [[start]]     启动虚拟机</p><p style="">    [[stop]]      关闭虚拟机</p><p style="">    [[enable]]    设置虚拟机为开机自启</p><p style="">    [[disable]]   关闭虚拟机开机自启功能</p><p style="">    EOF</p><p style="">    ;;</p><p style="">esac</p><p style="">```</p><p style="">#### 83）调整虚拟机内存参数的 shell 脚本</p><p style="">```</p><p style="">#!/bin/bash</p><p style=""># 调整虚拟机内存参数的 shell 脚本 </p><p style=""># 脚本通过调用 virsh 命令实现对虚拟机的管理,如果没有该命令,需要安装 libvirt‐client 软件包</p><p style="">cat &lt;&lt; EOF</p><p style="">1.调整虚拟机最大内存数值</p><p style="">2.调整实际分配给虚拟机的内存数值</p><p style="">EOF</p><p style="">read -p "请选择[1‐2]:" select</p><p style="">case $select in</p><p style="">  1)</p><p style="">      read -p "请输入虚拟机名称" name</p><p style="">      read -p "请输入最大内存数值(单位:k):" size</p><p style="">      virsh setmaxmem $name --size $size --config</p><p style="">      ;;</p><p style="">  2)</p><p style="">      read -p "请输入虚拟机名称" name</p><p style="">      read -p "请输入实际分配内存数值(单位:k):" size</p><p style="">      virsh setmem $name $size</p><p style="">      ;;</p><p style="">  *)</p><p style="">      echo "Error"</p><p style="">      ;;</p><p style="">esac</p><p style="">```</p><p style="">#### 84）查看 KVM 虚拟机中的网卡信息(不需要进入启动或进入虚拟机)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 查看 KVM 虚拟机中的网卡信息(不需要进入启动或进入虚拟机) </p><p style=""># 该脚本使用 guestmount 工具,可以将虚拟机的磁盘系统挂载到真实机文件系统中</p><p style=""># Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具</p><p style=""># 虚拟机可以启动或者不启动都不影响该脚本的使用</p><p style=""># 将虚拟机磁盘文件挂载到文件系统后,就可以直接读取磁盘文件中的网卡配置文件中的数据</p><p style="">clear</p><p style="">mountpoint="/media/virtimage"</p><p style="">[ ! -d $mountpoint ] &amp;&amp; mkdir $mountpoint</p><p style="">read -p "输入虚拟机名称:" name</p><p style="">echo "请稍后..."</p><p style=""># 如果有设备挂载到该挂载点,则先 umount 卸载</p><p style="">if mount | grep -q "$mountpoint" ;then</p><p style="">  umount $mountpoint</p><p style="">fi</p><p style=""># 只读的方式,将虚拟机的磁盘文件挂载到特定的目录下,这里是/media/virtimage 目录</p><p style="">guestmount -r -d $name -i $mountpoint</p><p style="">echo</p><p style="">echo "‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐"</p><p style="">echo -e "\033[32m$name 虚拟机中网卡列表如下:\033[0m"</p><p style="">dev=$(ls /media/virtimage/etc/sysconfig/network‐scripts/ifcfg-* |awk -F"[/‐]" '{print $9}')</p><p style="">echo $dev</p><p style="">echo "‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐"</p><p style="">echo</p><p style="">echo</p><p style="">echo "+++++++++++++++++++++++++++++++++++++++++++"</p><p style="">echo -e "\033[32m 网卡 IP 地址信息如下:\033[0m"</p><p style="">for i in $dev</p><p style="">do</p><p style="">  echo -n "$i:"</p><p style="">  grep -q "IPADDR" /media/virtimage/etc/sysconfig/network‐scripts/ifcfg-$i || echo "未配置 IP地址"</p><p style="">  awk -F= '/IPADDR/{print $2}' /media/virtimage/etc/sysconfig/network-scripts/ifcfg-$i</p><p style="">done</p><p style="">echo "+++++++++++++++++++++++++++++++++++++++++++"</p><p style="">```</p><p style="">#### 85）不登陆虚拟机,修改虚拟机网卡 IP 地址</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 不登陆虚拟机,修改虚拟机网卡 IP 地址 </p><p style=""># 该脚本使用 guestmount 工具,Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具</p><p style=""># 脚本在不登陆虚拟机的情况下,修改虚拟机的 IP 地址信息</p><p style=""># 在某些环境下,虚拟机没有 IP 或 IP 地址与真实主机不在一个网段</p><p style=""># 真实主机在没有 virt‐manger 图形的情况下,远程连接虚拟机很麻烦</p><p style=""># 该脚本可以解决类似的问题</p><p style="">read -p "请输入虚拟机名称:" name</p><p style="">if virsh domstate $name | grep -q running ;then</p><p style="">  echo "修改虚拟机网卡数据,需要关闭虚拟机"</p><p style="">  virsh destroy $name</p><p style="">fi</p><p style="">mountpoint="/media/virtimage"</p><p style="">[ ! -d $mountpoint ] &amp;&amp; mkdir $mountpoint</p><p style="">echo "请稍后..."</p><p style="">if mount | grep -q "$mountpoint" ;then</p><p style="">  umount $mountpoint</p><p style="">fi</p><p style="">guestmount  -d $name -i $mountpoint</p><p style="">read -p "请输入需要修改的网卡名称:" dev</p><p style="">read -p "请输入 IP 地址:" addr</p><p style=""># 判断原本网卡配置文件中是否有 IP 地址,有就修改该 IP,没有就添加一个新的 IP 地址</p><p style="">if grep -q "IPADDR"  $mountpoint/etc/sysconfig/network‐scripts/ifcfg‐$dev ;then</p><p style="">  sed -i "/IPADDR/s/=.*/=$addr/"  $mountpoint/etc/sysconfig/network‐scripts/ifcfg‐$dev</p><p style="">else</p><p style="">  echo "IPADDR=$addr" &gt;&gt; $mountpoint/etc/sysconfig/network‐scripts/ifcfg‐$dev</p><p style="">fi</p><p style=""># 如果网卡配置文件中有客户配置的 IP 地址,则脚本提示修改 IP 完成</p><p style="">awk -F= -v x=$addr '$2==x{print "完成..."}'  $mountpoint/etc/sysconfig/network‐scripts/ifcfg-$dev</p><p style="">```</p><p style="">#### 86）破解虚拟机密码,无密码登陆虚拟机系统</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 破解虚拟机密码,无密码登陆虚拟机系统 </p><p style=""># 该脚本使用 guestmount 工具,Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具</p><p style="">read -p "请输入虚拟机名称:" name</p><p style="">if virsh domstate $name | grep -q running ;then</p><p style="">  echo "破解,需要关闭虚拟机"</p><p style="">  virsh destroy $name</p><p style="">fi</p><p style="">mountpoint="/media/virtimage"</p><p style="">[ ! -d $mountpoint ] &amp;&amp; mkdir $mountpoint</p><p style="">echo "请稍后..."</p><p style="">if mount | grep -q "$mountpoint" ;then</p><p style="">  umount $mountpoint</p><p style="">fi</p><p style="">guestmount -d $name -i $mountpoint</p><p style=""># 将 passwd 中密码占位符号 x 删除,该账户即可实现无密码登陆系统</p><p style="">sed -i "/^root/s/x//" $mountpoint/etc/passwd</p><p style="">```</p><p style="">#### 87）Shell 脚本对信号的处理,执行脚本后,按键盘 Ctrl+C 无法终止的脚本</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># Shell 脚本对信号的处理,执行脚本后,按键盘 Ctrl+C 无法终止的脚本 </p><p style=""># 使用 trap 命令可以拦截用户通过键盘或 kill 命令发送过来的信号</p><p style=""># 使用 kill ‐l 可以查看 Linux 系统中所有的信号列表,其中 2 代表 Ctrl+C</p><p style=""># trap 当发现有用户 ctrl+C 希望终端脚本时,就执行 echo "暂停 10s";sleep 10 这两条命令</p><p style=""># 另外用户使用命令:[ kill ‐2 脚本的 PID ] 也可以中断脚本和 Ctrl+C 一样的效果,都会被 trap 拦截</p><p style="">trap 'echo "暂停 10s";sleep 10' 2</p><p style="">while :</p><p style="">do</p><p style="">  echo "go go go"</p><p style="">done</p><p style="">```</p><p style="">#### 88）一键部署 memcached</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 一键部署 memcached </p><p style=""># 脚本用源码来安装 memcached 服务器</p><p style=""># 注意:如果软件的下载链接过期了,请更新 memcached 的下载链接</p><p style="">wget http://www.memcached.org/files/memcached-1.5.1.tar.gz</p><p style="">yum -y install gcc</p><p style="">tar -xf  memcached‐1.5.1.tar.gz</p><p style="">cd memcached‐1.5.1</p><p style="">./configure</p><p style="">make</p><p style="">make install</p><p style="">```</p><p style="">#### 89）一键配置 VNC 远程桌面服务器(无密码版本)</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 一键配置 VNC 远程桌面服务器(无密码版本)</p><p style=""># 脚本配置的 VNC 服务器,客户端无需密码即可连接</p><p style=""># 客户端仅有查看远程桌面的权限,没有鼠标和键盘的操作权限</p><p style="">rpm --quiet -q tigervnc‐server</p><p style="">if [  $? -ne  0 ];then</p><p style="">  yum  -y  tigervnc‐server</p><p style="">fi</p><p style="">x0vncserver AcceptKeyEvents=0 AlwaysShared=1 \</p><p style="">AcceptPointerEvents=0 SecurityTypes=None  rfbport=5908</p><p style="">```</p><p style="">#### 90）关闭 SELinux</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 关闭 SELinux </p><p style="">sed -i  '/^SELINUX/s/=.*/=disabled/' /etc/selinux/config</p><p style="">setenforce 0</p><p style="">```</p><p style="">#### 91）查看所有虚拟机磁盘使用量以及CPU使用量信息</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 查看所有虚拟机磁盘使用量以及CPU使用量信息 </p><p style="">virt‐df</p><p style="">read -n1 "按任意键继续" key</p><p style="">virt‐top</p><p style="">```</p><p style="">#### 92）使用 shell 脚本打印图形</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用 shell 脚本打印如下图形: </p><p style=""># 打印第一组图片</p><p style=""># for(())为类 C 语言的语法格式,也可以使用 for i  in;do  ;done 的格式替换</p><p style=""># for((i=1;i&lt;=9;i++))循环会执行 9 次,i 从 1 开始到 9,每循环一次 i 自加 1</p><p style="">clear</p><p style="">for (( i=1; i&lt;=9; i++ ))</p><p style="">do</p><p style="">  for (( j=1; j&lt;=i; j++ ))</p><p style="">  do</p><p style="">    echo -n "$i"</p><p style="">  done</p><p style="">  echo ""</p><p style="">done</p><p style="">read  -n1  "按任意键继续"  key</p><p style="">[[打印第二组图片]]</p><p style="">clear</p><p style="">for (( i=1; i&lt;=5; i++ )) </p><p style="">do</p><p style="">  for (( j=1; j&lt;=i; j++ ))</p><p style="">  do</p><p style="">    echo -n " |"</p><p style="">  done</p><p style="">  echo "_ "</p><p style="">done</p><p style="">read  -n1  "按任意键继续"  key</p><p style="">[[打印第三组图片]]</p><p style="">clear</p><p style="">for (( i=1; i&lt;=5; i++ ))</p><p style="">do</p><p style="">  for (( j=1; j&lt;=i; j++ ))</p><p style="">  do</p><p style="">    echo -n " *"</p><p style="">  done</p><p style="">  echo ""</p><p style="">done</p><p style="">for (( i=5; i&gt;=1; i‐‐ ))</p><p style="">do</p><p style="">  for (( j=1; j&lt;=i; j++ ))</p><p style="">  do</p><p style="">    echo -n " *"</p><p style="">  done</p><p style="">  echo ""</p><p style="">done</p><p style="">```</p><p style="">#### 93）根据计算机当前时间,返回问候语,可以将该脚本设置为开机启动</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 根据计算机当前时间,返回问候语,可以将该脚本设置为开机启动 </p><p style=""># 00‐12 点为早晨,12‐18 点为下午,18‐24 点为晚上</p><p style=""># 使用 date 命令获取时间后,if 判断时间的区间,确定问候语内容</p><p style="">tm=$(date +%H)</p><p style="">if [ $tm -le 12 ];then</p><p style="">  msg="Good Morning $USER"</p><p style="">elif [ $tm -gt 12 -a $tm -le 18 ];then</p><p style="">    msg="Good Afternoon $USER"</p><p style="">else</p><p style="">    msg="Good Night $USER"</p><p style="">fi</p><p style="">echo "当前时间是:$(date +"%Y‐%m‐%d %H:%M:%S")"</p><p style="">echo -e "\033[34m$msg\033[0m"</p><p style="">```</p><p style="">#### 94）读取用户输入的账户名称,将账户名写入到数组保存</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 读取用户输入的账户名称,将账户名写入到数组保存 </p><p style=""># 定义数组名称为 name,数组的下标为 i,小标从 0 开始,每输入一个账户名,下标加 1,继续存下一个账户</p><p style=""># 最后,输入 over,脚本输出总结性信息后脚本退出</p><p style="">i=0</p><p style="">while :</p><p style="">do</p><p style="">  read -p "请输入账户名,输入 over 结束:" key</p><p style="">  if [ $key == "over" ];then </p><p style="">    break</p><p style="">    else</p><p style="">    name[$i]=$key</p><p style="">    let i++</p><p style="">    fi</p><p style="">done</p><p style="">echo "总账户名数量:${#name[*]}"</p><p style="">echo "${name[@]}"</p><p style="">```</p><p style="">#### 95）判断文件或目录是否存在</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 判断文件或目录是否存在 </p><p style="">if [ $# -eq 0 ] ;then</p><p style="">echo "未输入任何参数,请输入参数"</p><p style="">echo "用法:$0 [文件名|目录名]"</p><p style="">fi</p><p style="">if [ -f $1 ];then</p><p style="">  echo "该文件,存在"</p><p style="">  ls -l $1</p><p style="">else</p><p style="">  echo "没有该文件"</p><p style="">fi</p><p style="">if [ -d  $1 ];then</p><p style="">     echo "该目录,存在"</p><p style="">     ls -ld  $2</p><p style="">else</p><p style="">     echo "没有该目录"</p><p style="">fi</p><p style="">```</p><p style="">#### 96）打印各种格式的时间</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 打印各种时间格式 </p><p style="">echo "显示星期简称(如:Sun)"</p><p style="">date +%a</p><p style="">echo "显示星期全称(如:Sunday)"</p><p style="">date +%A</p><p style="">echo "显示月份简称(如:Jan)"</p><p style="">date +%b</p><p style="">echo "显示月份全称(如:January)"</p><p style="">date +%B</p><p style="">echo "显示数字月份(如:12)"</p><p style="">date +%m</p><p style="">echo "显示数字日期(如:01 号)"</p><p style="">date +%d</p><p style="">echo "显示数字年(如:01 号)"</p><p style="">date +%Y echo "显示年‐月‐日"</p><p style="">date +%F</p><p style="">echo "显示小时(24 小时制)"</p><p style="">date +%H</p><p style="">echo "显示分钟(00..59)"</p><p style="">date +%M</p><p style="">echo "显示秒"</p><p style="">date +%S</p><p style="">echo "显示纳秒"</p><p style="">date +%N</p><p style="">echo "组合显示"</p><p style="">date +"%Y%m%d %H:%M:%S"</p><p style="">```</p><p style="">#### 97）使用 egrep 过滤 MAC 地址</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用 egrep 过滤 MAC 地址 </p><p style=""># MAC 地址由 16 进制组成,如 AA:BB:CC:DD:EE:FF</p><p style=""># [0‐9a‐fA‐F]{2}表示一段十六进制数值,{5}表示连续出现5组前置:的十六进制</p><p style="">egrep "[0‐9a‐fA‐F]{2}(:[0‐9a‐fA‐F]{2}){5}" $1</p><p style="">```</p><p style="">#### 98）统计双色球各个数字的中奖概率</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 统计双色球各个数字的中奖概率 </p><p style=""># 往期双色球中奖号码如下:</p><p style=""># 01 04 11 28 31 32  16</p><p style=""># 04 07 08 18 23 24  02</p><p style=""># 02 05 06 16 28 29  04</p><p style=""># 04 19 22 27 30 33  01</p><p style=""># 05 10 18 19 30 31  03</p><p style=""># 02 06 11 12 19 29  06</p><p style=""># 统计篮球和红球数据出现的概率次数(篮球不分顺序,统计所有篮球混合在一起的概率)</p><p style="">awk '{print $1"\n"$2"\n"$3"\n"$4"\n"$5"\n"$6}' 1.txt | sort | uniq -c | sort</p><p style="">awk '{print $7}' 1.txt | sort | uniq -c | sort</p><p style="">```</p><p style="">#### 99）生成签名私钥和证书</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 生成签名私钥和证书 </p><p style="">read -p "请输入存放证书的目录:" dir</p><p style="">if [ ! -d $dir ];then</p><p style="">  echo "该目录不存在"</p><p style="">  exit</p><p style="">fi</p><p style="">read -p "请输入密钥名称:" name</p><p style=""># 使用 openssl 生成私钥</p><p style="">openssl genrsa -out ${dir}/${name}.key</p><p style=""># 使用 openssl 生成证书 [[subj]] 选项可以在生成证书时,非交互自动填写 Common Name 信息</p><p style="">openssl req -new -x509 -key ${dir}/${name}.key -subj "/CN=common" -out ${dir}/${name}.crt</p><p style="">```</p><p style="">#### 100）使用awk编写的wc程序</p><p style="">```bash</p><p style="">#!/bin/bash</p><p style=""># 使用awk编写的wc程序 </p><p style=""># 自定义变量 chars 变量存储字符个数,自定义变量 words 变量存储单词个数</p><p style=""># awk 内置变量 NR 存储行数</p><p style=""># length()为 awk 内置函数,用来统计每行的字符数量,因为每行都会有一个隐藏的$,所以每次统计后都+1</p><p style=""># wc 程序会把文件结尾符$也统计在内,可以使用 cat ‐A 文件名,查看该隐藏字符</p><p style="">awk '{chars+=length($0)+1;words+=NF} END{print NR,words,chars}' $1</p><p style="">```</p><p style=""></p>